#!/usr/bin/env python3
"""
VoiceX BLE Communication Module (bluezero version)
–†–∞–±–æ—á–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è BLE Peripheral (—Å–µ—Ä–≤–µ—Ä) –¥–ª—è —Å–≤—è–∑–∏ —Å –º–æ–±–∏–ª—å–Ω—ã–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º
"""

import json
import logging
import threading
import time
from bluezero import peripheral
from .protocols import VoiceXProtocol, DeviceStatus, VoiceXState

logger = logging.getLogger(__name__)

class BLECommunicator(VoiceXProtocol):
    """BLE –∫–æ–º–º—É–Ω–∏–∫–∞—Ç–æ—Ä –¥–ª—è VoiceX —á–µ—Ä–µ–∑ bluezero (Peripheral mode)"""

    # UUIDs (–¥–æ–ª–∂–Ω—ã —Å–æ–≤–ø–∞–¥–∞—Ç—å —Å –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ–º)
    VOICEX_SERVICE_UUID = '12345678-1234-1234-1234-123456789abc'
    STATUS_CHAR_UUID = '12345678-1234-1234-1234-123456789ab1'
    COMMAND_CHAR_UUID = '12345678-1234-1234-1234-123456789ab2'
    CONFIG_CHAR_UUID = '12345678-1234-1234-1234-123456789ab3'

    def __init__(self, voicex_engine):
        super().__init__(voicex_engine)
        self.peripheral = None
        self.running = False

        self.status_notify_func = None
        logger.info("üîµ BLECommunicator (bluezero) initialized")

    def _read_status(self):
        self._update_system_metrics()
        state_json = json.dumps(self.state.to_dict()).encode('utf-8')
        logger.debug(f"üì± Read status: {state_json}")
        return state_json

    def _write_command(self, value):
        try:
            command_str = value.decode('utf-8')
            command = json.loads(command_str)
            logger.info(f"üì± Command received: {command}")
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            threading.Thread(target=lambda: asyncio.run(self._process_command(command)), daemon=True).start()
        except Exception as e:
            logger.error(f"‚ùå Command write error: {e}")

    def _read_config(self):
        config = self._get_current_config()
        return json.dumps(config).encode('utf-8')

    def _write_config(self, value):
        try:
            config = json.loads(value.decode('utf-8'))
            threading.Thread(target=lambda: asyncio.run(self._apply_config(config)), daemon=True).start()
        except Exception as e:
            logger.error(f"‚ùå Config write error: {e}")

    async def start_server(self):
        """–ó–∞–ø—É—Å–∫ BLE Peripheral —Å–µ—Ä–≤–µ—Ä–∞"""
        logger.info("üîµ Starting BLE server via bluezero...")

        status_char = peripheral.Characteristic(
            uuid=self.STATUS_CHAR_UUID,
            properties=['read', 'notify'],
            secure=['read'],
            read_callback=self._read_status
        )

        command_char = peripheral.Characteristic(
            uuid=self.COMMAND_CHAR_UUID,
            properties=['write'],
            secure=['write'],
            write_callback=self._write_command
        )

        config_char = peripheral.Characteristic(
            uuid=self.CONFIG_CHAR_UUID,
            properties=['read', 'write'],
            secure=['read', 'write'],
            read_callback=self._read_config,
            write_callback=self._write_config
        )

        voicex_service = peripheral.Service(
            uuid=self.VOICEX_SERVICE_UUID,
            characteristics=[status_char, command_char, config_char]
        )

        self.peripheral = peripheral.Peripheral(
            adapter_addr=self._get_adapter_address(),
            local_name='VoiceX',
            services=[voicex_service]
        )

        self.running = True
        threading.Thread(target=self.peripheral.run, daemon=True).start()
        logger.info("‚úÖ BLE Peripheral server started")

    async def stop_server(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ BLE —Å–µ—Ä–≤–µ—Ä–∞"""
        if self.peripheral:
            self.running = False
            self.peripheral.quit()
            logger.info("üîµ BLE server stopped")

    def _get_adapter_address(self):
        # TODO: –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ –∞–¥—Ä–µ—Å —Ç–≤–æ–µ–≥–æ Bluetooth-–∞–¥–∞–ø—Ç–µ—Ä–∞
        # –ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã: hcitool dev
        return 'XX:XX:XX:XX:XX:XX'

    def get_connection_info(self):
        return {
            'protocol': 'BLE',
            'service_uuid': self.VOICEX_SERVICE_UUID,
            'server_running': self.running
        }




          #!/usr/bin/env python3
"""
VoiceX Communication Protocols
–û–±—â–∏–µ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã –∏ –±–∞–∑–æ–≤—ã–µ –∫–ª–∞—Å—Å—ã –¥–ª—è —Å–≤—è–∑–∏
"""

import logging
import time
import threading
from abc import ABC, abstractmethod
from dataclasses import dataclass, asdict
from enum import Enum
from typing import Dict, List, Callable, Any, Optional

logger = logging.getLogger(__name__)

class DeviceStatus(Enum):
    """–°—Ç–∞—Ç—É—Å—ã —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ VoiceX"""
    IDLE = "idle"
    READY = "ready"
    PROCESSING = "processing"
    CALIBRATING = "calibrating"
    ERROR = "error"
    UPDATING = "updating"

@dataclass
class VoiceXState:
    """–°–æ—Å—Ç–æ—è–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ VoiceX"""
    status: DeviceStatus = DeviceStatus.IDLE
    volume: int = 50  # 0-100
    signal_level: float = 0.0  # 0.0-1.0
    battery_level: int = 100  # 0-100
    cpu_usage: float = 0.0  # 0.0-100.0
    memory_usage: float = 0.0  # 0.0-100.0
    processing_mode: str = "normal"  # normal, quiet, loud, accessibility
    analog_soul_enabled: bool = True
    voicefixer_enabled: bool = True
    spatial_audio_enabled: bool = True
    is_wearing: bool = False
    sos_triggered: bool = False
    uptime_seconds: int = 0
    
    def to_dict(self) -> Dict:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ —Å–ª–æ–≤–∞—Ä—å –¥–ª—è JSON"""
        result = asdict(self)
        result['status'] = self.status.value
        return result

class VoiceXProtocol(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∫–ª–∞—Å—Å –¥–ª—è –≤—Å–µ—Ö –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–≤ —Å–≤—è–∑–∏"""
    
    def __init__(self, voicex_engine):
        self.voicex_engine = voicex_engine
        self.state = VoiceXState()
        self.status_callbacks: List[Callable] = []
        
        # –í—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞ –¥–ª—è uptime
        self.start_time = time.time()
    
    @abstractmethod
    async def start_server(self):
        """–ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞/—Å–ª—É–∂–±—ã"""
        pass
    
    @abstractmethod
    async def stop_server(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞/—Å–ª—É–∂–±—ã"""
        pass
    
    async def _process_command(self, command: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ (–æ–±—â–∞—è –ª–æ–≥–∏–∫–∞)"""
        cmd_type = command.get('type')
        
        if cmd_type == 'set_volume':
            volume = max(0, min(100, command.get('volume', 50)))
            self.state.volume = volume
            # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫ DSP –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä—É
            if hasattr(self.voicex_engine, 'dsp_processor'):
                self.voicex_engine.dsp_processor.set_volume(volume / 100.0)
            
            logger.info(f"üîä Volume set to {volume}%")
                
        elif cmd_type == 'set_mode':
            mode = command.get('mode', 'normal')
            if mode in ['normal', 'quiet', 'loud', 'accessibility']:
                self.state.processing_mode = mode
                await self._apply_processing_mode(mode)
                
        elif cmd_type == 'toggle_feature':
            feature = command.get('feature')
            enabled = command.get('enabled', True)
            
            if feature == 'analog_soul':
                self.state.analog_soul_enabled = enabled
                logger.info(f"üß† Analog Soul: {'enabled' if enabled else 'disabled'}")
            elif feature == 'voicefixer':
                self.state.voicefixer_enabled = enabled
                logger.info(f"üéØ VoiceFixer: {'enabled' if enabled else 'disabled'}")
            elif feature == 'spatial_audio':
                self.state.spatial_audio_enabled = enabled
                logger.info(f"üîä Spatial Audio: {'enabled' if enabled else 'disabled'}")
                
        elif cmd_type == 'start_calibration':
            self.state.status = DeviceStatus.CALIBRATING
            # –ó–∞–ø—É—Å–∫ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            threading.Thread(target=self._run_calibration, daemon=True).start()
            
        elif cmd_type == 'emergency_stop':
            self.state.sos_triggered = True
            await self._handle_sos()
            
        elif cmd_type == 'ping':
            # –ü—Ä–æ—Å—Ç–æ–π ping –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–≤—è–∑–∏
            logger.debug("üì° Ping received")
            
        elif cmd_type == 'get_diagnostics':
            return await self._get_diagnostics()
            
        else:
            logger.warning(f"‚ö†Ô∏è Unknown command type: {cmd_type}")
    
    async def _apply_processing_mode(self, mode: str):
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏"""
        mode_configs = {
            'normal': {'agc_target': 0.3, 'enhancement_strength': 1.0},
            'quiet': {'agc_target': 0.5, 'enhancement_strength': 1.3},
            'loud': {'agc_target': 0.2, 'enhancement_strength': 0.8},
            'accessibility': {'agc_target': 0.6, 'enhancement_strength': 1.5}
        }
        
        config = mode_configs.get(mode, mode_configs['normal'])
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∫ DSP
        if hasattr(self.voicex_engine, 'dsp_processor'):
            self.voicex_engine.dsp_processor.agc_target_rms = config['agc_target']
        
        logger.info(f"üéõÔ∏è Applied processing mode: {mode}")
    
    def _get_current_config(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        return {
            'volume': self.state.volume,
            'processing_mode': self.state.processing_mode,
            'features': {
                'analog_soul': self.state.analog_soul_enabled,
                'voicefixer': self.state.voicefixer_enabled,
                'spatial_audio': self.state.spatial_audio_enabled
            },
            'device_info': {
                'uptime_seconds': int(time.time() - self.start_time),
                'status': self.state.status.value
            }
        }
    
    async def _apply_config(self, config: Dict):
        """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"""
        if 'volume' in config:
            await self._process_command({'type': 'set_volume', 'volume': config['volume']})
        
        if 'processing_mode' in config:
            await self._process_command({'type': 'set_mode', 'mode': config['processing_mode']})
        
        # –û–±—Ä–∞–±–æ—Ç–∫–∞ features
        features = config.get('features', {})
        for feature_name, enabled in features.items():
            await self._process_command({
                'type': 'toggle_feature',
                'feature': feature_name,
                'enabled': enabled
            })
    
    def _run_calibration(self):
        """–ó–∞–ø—É—Å–∫ –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        try:
            logger.info("üéØ Starting calibration...")
            
            # –ó–¥–µ—Å—å –±—É–¥–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å VoiceXCalibrator
            # from voicex_main import VoiceXCalibrator
            # calibrator = VoiceXCalibrator(self.voicex_engine)
            # calibrator.run_calibration(duration_seconds=30)
            
            # –°–∏–º—É–ª—è—Ü–∏—è –∫–∞–ª–∏–±—Ä–æ–≤–∫–∏
            time.sleep(30)
            
            self.state.status = DeviceStatus.READY
            logger.info("‚úÖ Calibration completed")
            
        except Exception as e:
            logger.error(f"‚ùå Calibration error: {e}")
            self.state.status = DeviceStatus.ERROR
    
    async def _handle_sos(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ SOS —Å–∏–≥–Ω–∞–ª–∞"""
        logger.warning("üö® SOS signal triggered!")
        
        # –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º SOS –∑–≤—É–∫
        if hasattr(self.voicex_engine, 'play_sos_sound'):
            self.voicex_engine.play_sos_sound()
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
        def reset_sos():
            time.sleep(5)
            self.state.sos_triggered = False
        
        threading.Thread(target=reset_sos, daemon=True).start()
    
    def _update_system_metrics(self):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫"""
        try:
            import psutil
            
            self.state.cpu_usage = psutil.cpu_percent()
            self.state.memory_usage = psutil.virtual_memory().percent
            self.state.uptime_seconds = int(time.time() - self.start_time)
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å —Å–∏–≥–Ω–∞–ª–∞ –∏–∑ –∞—É–¥–∏–æ –¥–≤–∏–∂–∫–∞
            if hasattr(self.voicex_engine, 'get_signal_level'):
                self.state.signal_level = self.voicex_engine.get_signal_level()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å
            if hasattr(self.voicex_engine, 'is_running') and self.voicex_engine.is_running:
                if self.state.status == DeviceStatus.IDLE:
                    self.state.status = DeviceStatus.READY
            else:
                if self.state.status == DeviceStatus.READY:
                    self.state.status = DeviceStatus.IDLE
                
        except Exception as e:
            logger.error(f"‚ùå Metrics update error: {e}")
    
    async def _get_diagnostics(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
        try:
            import psutil
            
            diagnostics = {
                'system': {
                    'cpu_count': psutil.cpu_count(),
                    'memory_total': psutil.virtual_memory().total,
                    'disk_usage': psutil.disk_usage('/').percent,
                    'boot_time': psutil.boot_time()
                },
                'voicex': {
                    'engine_running': hasattr(self.voicex_engine, 'is_running') and self.voicex_engine.is_running,
                    'audio_latency': getattr(self.voicex_engine, 'audio_latency', 0),
                    'processing_latency': getattr(self.voicex_engine, 'processing_latency', 0)
                },
                'audio': {
                    'sample_rate': getattr(self.voicex_engine, 'sample_rate', 48000),
                    'chunk_size': getattr(self.voicex_engine, 'chunk_size', 2048),
                    'input_channels': 1,
                    'output_channels': 2
                }
            }
            
            return diagnostics
            
        except Exception as e:
            logger.error(f"‚ùå Diagnostics error: {e}")
            return {'error': str(e)}
    
    def add_status_callback(self, callback: Callable):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ callback –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏–π —Å—Ç–∞—Ç—É—Å–∞"""
        self.status_callbacks.append(callback)
    
    def notify_status_change(self, event_type: str, data: Any):
        """–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–∞"""
        for callback in self.status_callbacks:
            try:
                callback(event_type, data)
            except Exception as e:
                logger.error(f"Status callback error: {e}")

class CommandValidator:
    """–í–∞–ª–∏–¥–∞—Ç–æ—Ä –∫–æ–º–∞–Ω–¥ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
    
    ALLOWED_COMMANDS = [
        'set_volume', 'set_mode', 'toggle_feature', 
        'start_calibration', 'emergency_stop', 'ping', 'get_diagnostics'
    ]
    
    ALLOWED_MODES = ['normal', 'quiet', 'loud', 'accessibility']
    
    ALLOWED_FEATURES = ['analog_soul', 'voicefixer', 'spatial_audio']
    
    @classmethod
    def validate_command(cls, command: Dict) -> tuple[bool, str]:
        """–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–º–∞–Ω–¥—ã"""
        
        if not isinstance(command, dict):
            return False, "Command must be a dictionary"
        
        cmd_type = command.get('type')
        if not cmd_type:
            return False, "Command type is required"
        
        if cmd_type not in cls.ALLOWED_COMMANDS:
            return False, f"Unknown command type: {cmd_type}"
        
        # –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –≤–∞–ª–∏–¥–∞—Ü–∏–∏
        if cmd_type == 'set_volume':
            volume = command.get('volume')
            if not isinstance(volume, (int, float)) or not (0 <= volume <= 100):
                return False, "Volume must be between 0 and 100"
        
        elif cmd_type == 'set_mode':
            mode = command.get('mode')
            if mode not in cls.ALLOWED_MODES:
                return False, f"Invalid mode: {mode}"
        
        elif cmd_type == 'toggle_feature':
            feature = command.get('feature')
            if feature not in cls.ALLOWED_FEATURES:
                return False, f"Invalid feature: {feature}"
            
            enabled = command.get('enabled')
            if not isinstance(enabled, bool):
                return False, "Feature enabled must be boolean"
        
        return True, "Command is valid"

class SecurityManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –¥–ª—è –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–∏"""
    
    def __init__(self):
        self.failed_attempts = {}
        self.max_attempts = 5
        self.lockout_duration = 300  # 5 –º–∏–Ω—É—Ç
    
    def check_rate_limit(self, client_id: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ rate limiting"""
        current_time = time.time()
        
        if client_id in self.failed_attempts:
            attempts, last_attempt = self.failed_attempts[client_id]
            
            if attempts >= self.max_attempts:
                if current_time - last_attempt < self.lockout_duration:
                    return False  # –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω
                else:
                    # –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –ø–æ—Å–ª–µ lockout
                    del self.failed_attempts[client_id]
        
        return True
    
    def record_failed_attempt(self, client_id: str):
        """–ó–∞–ø–∏—Å—å –Ω–µ—É–¥–∞—á–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏"""
        current_time = time.time()
        
        if client_id in self.failed_attempts:
            attempts, _ = self.failed_attempts[client_id]
            self.failed_attempts[client_id] = (attempts + 1, current_time)
        else:
            self.failed_attempts[client_id] = (1, current_time)
    
    def record_successful_attempt(self, client_id: str):
        """–ó–∞–ø–∏—Å—å —É—Å–ø–µ—à–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏"""
        if client_id in self.failed_attempts:
            del self.failed_attempts[client_id]
